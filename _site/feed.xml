<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Anyinlover Blog</title>
    <description>在这里探索数据，发现真理</description>
    <link>http://anyinlover.github.io/</link>
    <atom:link href="http://anyinlover.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 29 May 2016 17:11:29 +0800</pubDate>
    <lastBuildDate>Sun, 29 May 2016 17:11:29 +0800</lastBuildDate>
    <generator>Jekyll v2.4.0</generator>
    
      <item>
        <title>test</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;加权系数的矩阵表示&lt;/h2&gt;
&lt;p&gt;令&lt;/p&gt;

&lt;p&gt;$W&lt;em&gt;{ii}=\frac{1}{2} w^{(i)}，W&lt;/em&gt;{ij}=0 \text{ for } i \neq j, \overrightarrow{z}=X\theta-\overrightarrow{y}, z_i=\theta^T x^{(i)}-y^{(i)}$&lt;/p&gt;

&lt;p&gt;，因此可以推导出下式：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[

\begin{align}
J(\theta) &amp;= (X\theta-\overrightarrow{y})^TW(X\theta-\overrightarrow{y}) \\
&amp;=\overrightarrow{z}^TW \overrightarrow{z} \\
&amp;=\frac{1}{2} \sum_{i=1}^m w^{(i)} z_i^2 \\
&amp;= \frac{1}{2} \sum_{i=1}^m w^{(i)} (\theta^T x^{(i)}-y^{(i)})^2
\end{align}
 %]]&gt;&lt;/script&gt;

&lt;h2 id=&quot;section-1&quot;&gt;局部加权的标准方程&lt;/h2&gt;
&lt;p&gt;根据上式得到的损失函数，可以计算如下：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[

\begin{align}
\nabla_{\theta}J(\theta)&amp;=\nabla_{\theta}\frac{1}2(X\theta-\overrightarrow{y})^T W (X\theta-\overrightarrow{y})\\
&amp;=\frac{1}2\nabla_{\theta}(\theta^T X^T W X\theta-\theta^TX^T W \overrightarrow{y}-\overrightarrow{y}^T W X\theta+\overrightarrow{y}^T W \overrightarrow{y})\\
&amp;=\frac{1}2\nabla_{\theta}tr(\theta^TX^T W X\theta-\theta^TX^T W \overrightarrow{y}-\overrightarrow{y}^T W X\theta+\overrightarrow{y}^T W \overrightarrow{y})\\
&amp;=\frac{1}2\nabla_{\theta}(tr\theta^TX^T W X\theta-2tr\overrightarrow{y}^T W X\theta)\\
&amp;=\frac{1}2(X^T W X\theta+X^TWX\theta-2X^TW^T\overrightarrow{y}）\\
&amp;=X^TWX\theta-X^TW\overrightarrow{y}
\end{align}
 %]]&gt;&lt;/script&gt;

&lt;p&gt;令上式为0，最终我们得出局部加权的标准方程为：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[

\begin{align}
X^TWX\theta&amp;=X^TW\overrightarrow{y}\\
\theta &amp;= (X^TWX)^{-1}X^TW\overrightarrow{y}
\end{align}
 %]]&gt;&lt;/script&gt;

&lt;h2 id=&quot;y&quot;&gt;以y的方差表示加权系数&lt;/h2&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[

\begin{align}
\ell(\theta)&amp;=\log{L(\theta)}\\
&amp;=\log\prod_{i=1}^m\frac{1}{\sqrt{2\pi}\sigma^{(i)}}\exp(-\frac{(y^{(i)}-\theta^Tx^{(i)})^2}{2(\sigma^{(i)})^2})\\
&amp;=\sum_{i=1}^m \log\frac{1}{\sqrt{2\pi}\sigma^{(i)}}\exp(-\frac{(y^{(i)}-\theta^Tx^{(i)})^2}{2(\sigma^{(i)})^2})\\
&amp;=\sum_{i=1}^m\log\frac{1}{\sqrt{2\pi}\sigma^{(i)}}-\frac{1}{2}\sum_{i=1}^{m}\frac{1}{(\sigma^{(i)})^2} (h_\theta(x^{(i)})-y^{(i)})^2 \\
&amp;=\sum_{i=1}^m\log\frac{1}{\sqrt{2\pi}\sigma^{(i)}} - \frac{1}{2}\sum_{i=1}^{m} w^{(i)} (h_\theta(x^{(i)})-y^{(i)})^2
\end{align}
 %]]&gt;&lt;/script&gt;

&lt;p&gt;即：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;w^{(i)} = \frac{1}{(\sigma^{(i)})^2} &lt;/script&gt;

&lt;h2 id=&quot;section-2&quot;&gt;回归问题&lt;/h2&gt;

&lt;h3 id=&quot;section-3&quot;&gt;实现一般回归&lt;/h3&gt;
&lt;p&gt;用标准方程来写一般回归是比较容易的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from numpy import *
import pandas as pd
orx = pd.read_csv(&#39;q2x.dat&#39;, sep = &#39;\s+&#39;, header=None).values
y = pd.read_csv(&#39;q2y.dat&#39;, sep = &#39;\s+&#39;, header=None).values.ravel()
X = hstack((ones((orx.shape[0],1)), orx))
theta = dot(dot(linalg.inv(dot(X.T,X)), X.T),y)
print(theta)

import matplotlib.pyplot as plt
plt.scatter(x = orx.ravel(), y = y, marker=&#39;x&#39;, color=&#39;blue&#39;)
plt.xlabel(&#39;x&#39;)
plt.ylabel(&#39;y&#39;)
plt.xlim(-10,15)
xl = arange(-10,16,1)
yl = theta[0]+theta[1]*xl
plt.plot(xl, yl)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;\img\ps1_2_1.png&quot; alt=&quot;ps1_2_1&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;实现局部加权线性回归&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;Xl = arange(-10, 15.01, 0.02)
def plot_t(t):
    plt.hold(&#39;on&#39;)
    Xl = arange(-10, 15.01, 0.02)
    Ylo = []
    for xl in Xl:
        w = exp(-(orx.ravel()-xl)**2/(2*t**2))
        W = diag(w)
        theta = dot(dot(dot(linalg.pinv(dot(dot(X.T,W),X)),X.T),W),y)
        yl = dot(theta.T,array([1,xl]))
        Ylo.append(yl)
        Yl = array(Ylo)
    plt.plot(Xl,Yl,color=&#39;red&#39;)

 plt.scatter(x = orx.ravel(), y = y, marker=&#39;x&#39;, color=&#39;blue&#39;)
plt.xlabel(&#39;x&#39;)
plt.ylabel(&#39;y&#39;)
plt.xlim(-10,15)
plot_t(0.8)
plot_t(0.3)
plot_t(2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最终的图形如下（这图还可以优化一下），局部线性回归可以较好的拟合散点。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\img\ps1_2_2.png&quot; alt=&quot;ps1_2_1&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;带宽的影响&lt;/h3&gt;
&lt;p&gt;带宽决定了影响模型的样本数量多少。带宽越小，影响模型的样本越少，模型也更容易受噪音影响，上面当带宽变0.1时，直接导致矩阵不可逆。带宽越大，影响模型的样本越多，模型更趋于一般线性回归。&lt;/p&gt;
</description>
        <pubDate>Mon, 30 May 2016 00:00:00 +0800</pubDate>
        <link>http://anyinlover.github.io/2016/05/30/test/</link>
        <guid isPermaLink="true">http://anyinlover.github.io/2016/05/30/test/</guid>
        
        <category>Ng机器学习系列</category>
        
        
      </item>
    
      <item>
        <title>独立成分分析</title>
        <description>&lt;p&gt;考虑一个鸡尾酒派对，不同位置的n个麦克风记录了n个说话者的声音。我们的目标是区分原始n个说话者的信号。&lt;/p&gt;

&lt;p&gt;用公式来表达，假设有一些数据&lt;script type=&quot;math/tex&quot;&gt;s \in {\mathbb{R}}^n&lt;/script&gt;通过n各独立源产生，我们观察到的是：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt; x = As &lt;/script&gt;

&lt;p&gt;这里A是一个未知的方矩阵被称为混合矩阵。重复观察可以得到数据集&lt;script type=&quot;math/tex&quot;&gt; \{x^{(i)};i=1,\cdots,m\} &lt;/script&gt;，目标就是还原源数据&lt;script type=&quot;math/tex&quot;&gt;s^{(i)}&lt;/script&gt;。&lt;/p&gt;

&lt;p&gt;令&lt;script type=&quot;math/tex&quot;&gt;W = A^{-1}&lt;/script&gt;为分离矩阵，我们的目标变成找到W,因为&lt;script type=&quot;math/tex&quot;&gt;s^{(i)}=Wx^{(i)}&lt;/script&gt;。令&lt;script type=&quot;math/tex&quot;&gt;w_i^T&lt;/script&gt;表示W的第i行，则&lt;script type=&quot;math/tex&quot;&gt;s_j^{(i)}=w_j^Tx^{(i)}&lt;/script&gt;。&lt;/p&gt;

&lt;h2 id=&quot;ica&quot;&gt;ICA的任意性&lt;/h2&gt;

&lt;p&gt;如果对源和混合矩阵没有任何先验知识，只是给出&lt;script type=&quot;math/tex&quot;&gt;x^{(i)}&lt;/script&gt;，容易看出A是具有一些任意性的。&lt;/p&gt;

&lt;p&gt;如果P是任意一个&lt;script type=&quot;math/tex&quot;&gt;n \times n&lt;/script&gt;的重排列矩阵，这意味这每一行每一列都只包含一个1，那么我们是无法区分W和PW的，因为源数据的排列次序不会影响观察到的x。&lt;/p&gt;

&lt;p&gt;同样的，对W进行系数的缩放也没有影响。&lt;/p&gt;

&lt;p&gt;对于非高斯分布的数据源而言，只存在上面两种任意性。如果数据源是高斯分布的，考虑下面的例子。&lt;script type=&quot;math/tex&quot;&gt;n=2, s \sim \mathcal{N}(0,I)&lt;/script&gt;。那么对于观察数据&lt;script type=&quot;math/tex&quot;&gt;x=As&lt;/script&gt;而言，x也是一个高斯分布，平均值为0，方差为&lt;script type=&quot;math/tex&quot;&gt;E[xx^T]=E[Ass^TA^T]=AA^T&lt;/script&gt;。现在令R是任意一个正交矩阵，即&lt;script type=&quot;math/tex&quot;&gt;RR^T=R^TR=I&lt;/script&gt;，则有&lt;script type=&quot;math/tex&quot;&gt;A&#39;=AR&lt;/script&gt;，当混合矩阵是&lt;script type=&quot;math/tex&quot;&gt;A&#39;&lt;/script&gt;时，我们观察到&lt;script type=&quot;math/tex&quot;&gt;x&#39;=A&#39;s&lt;/script&gt;。&lt;script type=&quot;math/tex&quot;&gt;x&#39;&lt;/script&gt;的分布同样属于高斯分布，平均值为0，方差为&lt;script type=&quot;math/tex&quot;&gt;E[x&#39;{x&#39;}^T]=E[A&#39;ss^T{A&#39;}^T]=E[ARss^T(AR)^T]=ARR^TA^T=AA^T&lt;/script&gt;。也就是无论混合矩阵是A还是&lt;script type=&quot;math/tex&quot;&gt;A&#39;&lt;/script&gt;，最终观察到的都是&lt;script type=&quot;math/tex&quot;&gt;\mathcal{N}(0,AA^T)&lt;/script&gt;的分布。&lt;/p&gt;

&lt;p&gt;上述讨论是建立在对称的标准多变量正态分布上的，尽管ICA不能在高斯分布数据中应用，在实际应用于非高斯分布数据中，只要数据足够多，是可以还原成n个独立源的。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;分布密度和线性转换&lt;/h2&gt;

&lt;p&gt;假设随机变量s的分布密度是&lt;script type=&quot;math/tex&quot;&gt;p_s(s)&lt;/script&gt;，那么x的分布密度&lt;script type=&quot;math/tex&quot;&gt;p_x&lt;/script&gt;可以用下式表示：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p_x(x)=p_s(Wx)\cdot | W |&lt;/script&gt;

&lt;h2 id=&quot;ica-1&quot;&gt;ICA算法&lt;/h2&gt;

&lt;p&gt;假设每个数据源&lt;script type=&quot;math/tex&quot;&gt;s_i&lt;/script&gt;的分布由分布密度&lt;script type=&quot;math/tex&quot;&gt;p_s&lt;/script&gt;给出，则s的联合分布由下式给出：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p(s) = \prod_{i=1}^n p_s(s_i)&lt;/script&gt;

&lt;p&gt;也可以得到&lt;script type=&quot;math/tex&quot;&gt;x=As=W^{-1}s&lt;/script&gt;的分布密度：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p(x) = \prod_{i=1}^n p_s(w_i^Tx) \cdot |W|&lt;/script&gt;

&lt;p&gt;回顾累积分布函数(cdf)的定义，&lt;script type=&quot;math/tex&quot;&gt;F(z_0)=P(z \leq z_0)= \int_{-\infty}^{z_0} p_z(z)dz&lt;/script&gt;，z的分布密度也可以通过求导得到&lt;script type=&quot;math/tex&quot;&gt;p_z(z)=F&#39;(z)&lt;/script&gt;。&lt;/p&gt;

&lt;p&gt;因此，要确定s的分布密度，只需要确定cdf，它从0增长到1。根据我们上面的讨论，cdf不能取高斯函数，我们选择S型函数&lt;script type=&quot;math/tex&quot;&gt;g(s)=1/(1+e^{-s})&lt;/script&gt;，（假如对源分布有先验知识，这里应该利用先验知识构建cdf）。&lt;/p&gt;

&lt;p&gt;方矩阵W是模型的参数，给定训练集&lt;script type=&quot;math/tex&quot;&gt;\{x^{(i)};i=1,\cdots,m\}&lt;/script&gt;，对数似然函数是：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\ell(W) = \sum_{i=1}^m \left( \sum_{j=1}^n \log g&#39;(w_j^Tx^{(i)}) + \log |W| \right)&lt;/script&gt;

&lt;p&gt;使用随机梯度上升法则更新W，对于一个训练样本&lt;script type=&quot;math/tex&quot;&gt;x^{(i)}&lt;/script&gt;，更新规则是：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt; W := W + \alpha \left(
\begin{bmatrix}
1-2g(w_1^Tx^{(i)}) \\
1-2g(w_2^Tx^{(i)}) \\
\vdots \\
1-2g(w_n^Tx^{(i)})\\
\end{bmatrix}
{x^{(i)}}^T + (W^T)^{-1} \right)&lt;/script&gt;

&lt;p&gt;上面的推导包含了样本独立分布的假设，因此可以直接来最大化&lt;script type=&quot;math/tex&quot;&gt;\prod_i p(x^{(i)}; W)&lt;/script&gt;。但实际上说话者案例中样本并非完全独立，它们是时间相关的。但假如样本数足够多，ICA算法仍然有效。事实上，当样本具有相关性时，有时候还帮助我们加快拟合，类似于随机排序功能。&lt;/p&gt;
</description>
        <pubDate>Mon, 23 May 2016 00:00:00 +0800</pubDate>
        <link>http://anyinlover.github.io/2016/05/23/independent-components-analysis/</link>
        <guid isPermaLink="true">http://anyinlover.github.io/2016/05/23/independent-components-analysis/</guid>
        
        <category>Ng机器学习系列</category>
        
        <category>机器学习理论</category>
        
        
      </item>
    
      <item>
        <title>主成分分析</title>
        <description>&lt;p&gt;前一讲因子分析中，将数据投射到k维子空间，它是一个可能性模型，使用EM算法拟合参数。本讲中的主成分分析完成类似的功能，但却简单的多，只需要用到特征向量，不需要借用EM算法。&lt;/p&gt;

&lt;p&gt;在实现PCA算法之前，需要先对数据进行预处理：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;令&lt;script type=&quot;math/tex&quot;&gt;\mu = \frac{1}{m} \sum_{i=1}^m x^{(i)}&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;将&lt;script type=&quot;math/tex&quot;&gt;x^{(i)}&lt;/script&gt; 用&lt;script type=&quot;math/tex&quot;&gt;x^{(i)} - \mu&lt;/script&gt;代替&lt;/li&gt;
  &lt;li&gt;计算&lt;script type=&quot;math/tex&quot;&gt;\sigma_j^2 = \frac{1}{m} \Sigma_i(x_j^{(i)})^2&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;将&lt;script type=&quot;math/tex&quot;&gt;x_j^{(i)}&lt;/script&gt;用&lt;script type=&quot;math/tex&quot;&gt;x_j^{(i)}/\sigma_j&lt;/script&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果知道两个特征的范围大小一致，后两步可以省略。&lt;/p&gt;

&lt;p&gt;现在我们就是要找出一个方向，使得投射后的数据仍然有高的方差。即最大化下式：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[

\begin{align}
\frac{1}{m} \sum_{i=1}^m ({x^{(i)}}^T u)^2 &amp;= \frac{1}{m} \sum_{i=1}^m u^T x^{(i)} {x^{(i)}}^T u \\
&amp;= u^T \left( \frac{1}{m} \sum_{i=1}^m x^{(i)} {x^{(i)}}^T \right) u
\end{align}
 %]]&gt;&lt;/script&gt;

&lt;p&gt;当&lt;script type=&quot;math/tex&quot;&gt;\|u\|_2 = 1&lt;/script&gt;时，很容易得知u取经验协方差矩阵$$\Sigma = \frac{1}{m} \sum_{i=1}^m x^{(i)} {x^{(i)}}^T的特征向量时为最大值。&lt;/p&gt;

&lt;p&gt;当想得到一维子空间时，u取首要特征向量。更一般化，要投射到k维子空间时，取头k个特征向量：&lt;script type=&quot;math/tex&quot;&gt;u_1, \cdots, u_k&lt;/script&gt;。&lt;/p&gt;

&lt;p&gt;子空间的特征可以用对应的向量表示：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt; y^{(i)} =
\begin{bmatrix}
u_1^T x^{(i)} \\
u_2^T x^{(i)} \\
\vdots \\
u_k^T x^{(i)} \\
\end{bmatrix}
\in
{\mathbb{R}}^k
&lt;/script&gt;

&lt;p&gt;PCA也被称为降维算法。向量&lt;script type=&quot;math/tex&quot;&gt;u_1, \cdots, u_k&lt;/script&gt;被称为k个主成分。&lt;/p&gt;

&lt;p&gt;PCA算法有很多应用场景。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;将数据压缩到二或三维可以用作可视化&lt;/li&gt;
  &lt;li&gt;在监督学习前使用PCA来降低数据复杂度，避免过拟合。&lt;/li&gt;
  &lt;li&gt;PCA算法可以用来降噪。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 22 May 2016 00:00:00 +0800</pubDate>
        <link>http://anyinlover.github.io/2016/05/22/principal-components-analysis/</link>
        <guid isPermaLink="true">http://anyinlover.github.io/2016/05/22/principal-components-analysis/</guid>
        
        <category>Ng机器学习系列</category>
        
        <category>机器学习理论</category>
        
        
      </item>
    
      <item>
        <title>使用子查询</title>
        <description>&lt;p&gt;本讲主要学习子查询及其使用。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;理解子查询&lt;/h2&gt;
&lt;p&gt;前面的&lt;code&gt;SELECT&lt;/code&gt;语句都是简单的查询，SQL还允许在查询中嵌套查询，这就是子查询。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;使用子查询过滤&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;SELECT cust_id
FROM Orders
WHERE order_num IN (SELECT order_num
					FROM OrderItems
					WHERE prod_id = &#39;RGAN01&#39;);
                    
SELECT cust_name, cust_contact
FROM Customers
WHERE cust_id IN (SELECT cust_id
				  FROM Orders
                  WHERE order_num IN (SELECT order_num
									  FROM OrderItems
                                      WHERE prod_id=&#39;RGAN01&#39;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意子查询虽然能达成目的，但经常不是最有效的方式。后续会讲到连接表也能达到同样的效果。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;使用子查询作为计算字段&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;SELECT cust_name, cust_state,
	(SELECT COUNT(*)
     FROM Orders
     WHERE Orders.cust_id=Customers.cust_id) AS orders
FROM Customers
ORDER BY cust_name;
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sat, 21 May 2016 00:00:00 +0800</pubDate>
        <link>http://anyinlover.github.io/2016/05/21/working-with-subqueries/</link>
        <guid isPermaLink="true">http://anyinlover.github.io/2016/05/21/working-with-subqueries/</guid>
        
        <category>编程语言</category>
        
        <category>SQL</category>
        
        
      </item>
    
      <item>
        <title>使用视图</title>
        <description>&lt;p&gt;本讲主要学习视图，原理及何时使用。可以看到视图能够简化操作。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;理解视图&lt;/h2&gt;

&lt;p&gt;视图是虚拟的表，它没有实体的数据，只是包含动态查询的结果。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;为何使用视图&lt;/h3&gt;

&lt;p&gt;视图有以下几个常见的用法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;重用SQL语句&lt;/li&gt;
  &lt;li&gt;简化复杂SQL操作&lt;/li&gt;
  &lt;li&gt;导出部分表&lt;/li&gt;
  &lt;li&gt;保护数据&lt;/li&gt;
  &lt;li&gt;更改数据的样式和表达&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当视图创建之后，它可以执行和表一样的操作。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;视图的规则和限制&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;视图的命名也必须是唯一的。&lt;/li&gt;
  &lt;li&gt;视图的数量没有限制。&lt;/li&gt;
  &lt;li&gt;创建视图需要有安全权限。&lt;/li&gt;
  &lt;li&gt;视图可以嵌套。&lt;/li&gt;
  &lt;li&gt;视图不可被索引，不能有触发器或默认值。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;创建视图&lt;/h2&gt;

&lt;p&gt;使用&lt;code&gt;CREATE VIEW&lt;/code&gt;语句创建视图。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;使用视图来简化复杂连接&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;CREATE VIEW ProductCustomers AS
SELECT cust_name, cust_contact, prod_id
FROM Customers, Orders, OrderItems
WHERE Customers.cust_id=Orders.cust_id
AND OrderItems.order_num=Orders.order_num;

SELECT cust_name, cust_contact
FROM ProductCustomers
WHERE prod_id=&#39;RGAN01&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-5&quot;&gt;使用视图更改数据样式&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;Create VIEW VendorLocations AS
SELECT CONCAT(vend_name, &#39; (&#39;, vend_country, &#39;)&#39;)
AS vend_title
FROM Vendors;

SELECT * FROM vendorlocations;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-6&quot;&gt;使用视图过滤不必要的数据&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;CREATE VIEW CustomerEMailList AS
SELECT cust_id, cust_name, cust_email
FROM Customers
WHERE cust_email IS NOT NULL;

SELECT * FROM CustomerEMailList;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-7&quot;&gt;使用视图表示计算字段&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;CREATE VIEW OrderItemsExpanded AS
SELECT order_num,
		prod_id,
        quantity,
        item_price,
        quantity*item_price AS expanded_price
FROM OrderItems;

SELECT * FROM OrderItemsExpanded
WHERE order_num=20008;
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sat, 21 May 2016 00:00:00 +0800</pubDate>
        <link>http://anyinlover.github.io/2016/05/21/using-views/</link>
        <guid isPermaLink="true">http://anyinlover.github.io/2016/05/21/using-views/</guid>
        
        <category>编程语言</category>
        
        <category>SQL</category>
        
        
      </item>
    
      <item>
        <title>使用数据处理函数</title>
        <description>&lt;p&gt;本讲中主要学习什么是函数，数据库支持哪些类型的函数，以及如何使用这些函数。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;理解函数&lt;/h2&gt;

&lt;p&gt;和其他语言一样，SQL也支持使用函数来处理数据。比如前面提到的&lt;code&gt;RTRIM&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;但SQL函数有一个问题，就是和数据库管理系统强相关。不同的数据库支持的函数差别较大。因此，使用函数来处理数据时，一个好的习惯是加上注释。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;使用函数&lt;/h2&gt;
&lt;p&gt;大部分SQL实现了下面四种类型的函数：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;文本函数，处理文本字符串。&lt;/li&gt;
  &lt;li&gt;数字函数，数学运算。&lt;/li&gt;
  &lt;li&gt;时间日期函数。&lt;/li&gt;
  &lt;li&gt;系统函数。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;函数除了使用在&lt;code&gt;SELECT&lt;/code&gt;部分，也可以使用在SQL语句的其他部分，比如&lt;code&gt;WHERE&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;文本处理函数&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;SELECT vend_name, UPPER(vend_name) AS vend_name_upcase
FROM Vendors
ORDER BY vend_name;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是一些通用的文本处理函数：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;函数&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;LEFT()&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;从左取子字符串&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;LENGTH()&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;字符串长度&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;LOWER()&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;字符串小写&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;LTRIM()&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;截除字符串首空格&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;RIGHT()&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;从右取字符串&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;RTRIM()&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;截除字符串尾空格&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;SOUNDEX()&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;返回字符串音值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;UPPER()&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;字符串大写&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这里面&lt;code&gt;SOUNDEX()&lt;/code&gt;比较特殊，用来查找发音相似的字符串：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;SELECT cust_name, cust_contact
FROM Customers
WHERE SOUNDEX(cust_contact)=SOUNDEX(&#39;Michael Green&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-3&quot;&gt;日期时间处理函数&lt;/h2&gt;

&lt;p&gt;日期和时间在数据库中以数据库管理系统特有的格式存储，实际使用时需要通过日期时间处理函数来调用，这一部分函数非常重要，但同时也非常不具有普遍性。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;SELECT order_num
FROM Orders
WHERE YEAR(order_date)=2012;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体的日期时间处理函数需要参照不同SQL的产品文档。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;数字函数&lt;/h2&gt;

&lt;p&gt;数字函数和上面两者相比最不常用，却是最普遍性的。下面列举一些常见的数字处理函数：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;ABS()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;COS()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;EXP()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;PI()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;SIN()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;SQRT()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;TAN()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 21 May 2016 00:00:00 +0800</pubDate>
        <link>http://anyinlover.github.io/2016/05/21/using-data-manipulation-functions/</link>
        <guid isPermaLink="true">http://anyinlover.github.io/2016/05/21/using-data-manipulation-functions/</guid>
        
        <category>编程语言</category>
        
        <category>SQL</category>
        
        
      </item>
    
      <item>
        <title>更新和删除数据</title>
        <description>&lt;p&gt;本讲主要学习&lt;code&gt;UPDATE&lt;/code&gt;和&lt;code&gt;DELETE&lt;/code&gt;语句来操作数据。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;更新数据&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;UPDATE&lt;/code&gt;主要有两种用法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;更新特定行&lt;/li&gt;
  &lt;li&gt;更新所有行&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;UPDATE Customers
SET cust_email=&#39;kim@thetoystore.com&#39;
WHERE cust_id=&#39;1000000005&#39;;

UPDATE Customers
SET cust_contact=&#39;Sam Roberts&#39;,
	cust_email=&#39;sam@toyland.com&#39;
WHERE cust_id=&#39;1000000006&#39;;

UPDATE Customers
SET cust_email=NULL
WHERE cust_id=&#39;1000000005&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;删除数据&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;DELETE FROM Customers
WHERE cust_id=&#39;1000000008&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意如果要删除的行中存在其他表的外键，那么删除操作是无法完成的。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;更新删除数据指南&lt;/h2&gt;

&lt;p&gt;下面是一些实用的更新删除数据指南：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;永远不要在没有&lt;code&gt;WHERE&lt;/code&gt;分句的情况下更新和删除，除非你真的想操作所有行。&lt;/li&gt;
  &lt;li&gt;确保每张表都有一个主键，尽可能在&lt;code&gt;WHERE&lt;/code&gt;分句中使用它。&lt;/li&gt;
  &lt;li&gt;在用&lt;code&gt;WHERE&lt;/code&gt;分句更新删除前，先用&lt;code&gt;SELECT&lt;/code&gt;测试查看。&lt;/li&gt;
  &lt;li&gt;使用数据库的强制参考完整性特性，即上面提到的外键。&lt;/li&gt;
  &lt;li&gt;考虑DBA强制在更新删除时使用&lt;code&gt;WHERE&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 21 May 2016 00:00:00 +0800</pubDate>
        <link>http://anyinlover.github.io/2016/05/21/updating-and-deleting-data/</link>
        <guid isPermaLink="true">http://anyinlover.github.io/2016/05/21/updating-and-deleting-data/</guid>
        
        <category>编程语言</category>
        
        <category>SQL</category>
        
        
      </item>
    
      <item>
        <title>统计函数</title>
        <description>&lt;p&gt;本讲主要学习SQL统计函数来总结整表数据。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;使用统计函数&lt;/h2&gt;

&lt;p&gt;SQL提供了五种统计函数，用于对数据进行一个总结性的了解。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;函数&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;AVG()&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;平均值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;COUNT()&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;行数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;MAX()&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;最高值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;MIN()&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;最低值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;SUM()&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;和值&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;avg&quot;&gt;&lt;code&gt;AVG()&lt;/code&gt;函数&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;SELECT AVG(prod_price) AS avg_price
FROM Products;

SELECT AVG(prod_price) AS avg_price
FROM Products
WHERE vend_id = &#39;DLL01&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;NULL&lt;/code&gt;值会被&lt;code&gt;AVG()&lt;/code&gt;忽略不计。&lt;/p&gt;

&lt;h3 id=&quot;count&quot;&gt;&lt;code&gt;COUNT()&lt;/code&gt;函数&lt;/h3&gt;

&lt;p&gt;使用&lt;code&gt;COUNT(*)&lt;/code&gt;会计算所有的行数，包括&lt;code&gt;NULL&lt;/code&gt;值的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;SELECT COUNT(*) AS num_cust
FROM Customers;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用&lt;code&gt;COUNT(column)&lt;/code&gt;则会把&lt;code&gt;NULL&lt;/code&gt;值排除在外。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;SELECT COUNT(cust_email) AS num_cust
FROM Customers;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;max&quot;&gt;&lt;code&gt;MAX()&lt;/code&gt;函数&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;SELECT MAX(prod_price) AS max_price
FROM Products;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除了应用在数字数据上，&lt;code&gt;MAX()&lt;/code&gt;也可以应用在文本数据上。&lt;/p&gt;

&lt;h3 id=&quot;min&quot;&gt;&lt;code&gt;MIN()&lt;/code&gt;函数&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;SELECT MIN(prod_price) AS min_price
FROM Products;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和&lt;code&gt;MAX()&lt;/code&gt;类似，&lt;code&gt;MIN()&lt;/code&gt;也能应用在文本数据上。&lt;/p&gt;

&lt;h3 id=&quot;sum&quot;&gt;&lt;code&gt;SUM()&lt;/code&gt;函数&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;SELECT SUM(quantity) AS items_ordered
FROM OrderItems
WHERE order_num=20005;

SELECT SUM(item_price*quantity) AS total_price
FROM OrderItems
WHERE order_num=20005;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;独特值统计&lt;/h2&gt;

&lt;p&gt;如果要计算独特值得统计数据，可以使用&lt;code&gt;DISTINCT&lt;/code&gt;关键字，但注意只能配合列名使用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;SELECT AVG(DISTINCT prod_price) AS avg_price
FROM Products
WHERE vend_id=&#39;DLL01&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-2&quot;&gt;联合统计函数&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;SELECT COUNT(*) AS num_items,
		MIN(prod_price) AS price_min,
      	MAX(prod_price) AS price_max,
        AVG(prod_price) AS price_avg
FROM Products;
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sat, 21 May 2016 00:00:00 +0800</pubDate>
        <link>http://anyinlover.github.io/2016/05/21/summarizing-data/</link>
        <guid isPermaLink="true">http://anyinlover.github.io/2016/05/21/summarizing-data/</guid>
        
        <category>编程语言</category>
        
        <category>SQL</category>
        
        
      </item>
    
      <item>
        <title>连接表</title>
        <description>&lt;p&gt;本讲主要学习连接表的作用和创建。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;理解连接&lt;/h2&gt;

&lt;p&gt;连接表是SQL语句的一个重要特性，也是&lt;code&gt;SELECT&lt;/code&gt;中主要的操作。理解连接和连接语法是学习SQL中非常重要的一部分。&lt;/p&gt;

&lt;p&gt;在理解连接之前，有必要先了解关系表和关系型数据库的设计。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;理解关系表&lt;/h3&gt;
&lt;p&gt;关系表被设计成用来将信息分割成多张表，每张条对应一种数据类型。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;为何使用连接&lt;/h3&gt;
&lt;p&gt;将数据分散在不同表里可以更高效的存储，更简单的操作，以及更好的扩展。&lt;/p&gt;

&lt;p&gt;但当要获取的数据分散在不同表里时，就需要使用连接使得&lt;code&gt;SELECT&lt;/code&gt;操作可以从多表中获取数据。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;创建连接&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;SELECT vend_name, prod_name, prod_price
FROM Vendors, Products
WHERE Vendors.vend_id=Products.vend_id;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;where&quot;&gt;&lt;code&gt;WHERE&lt;/code&gt;分句的重要性&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;WHERE&lt;/code&gt;分句指定了两张表的关系。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;内连接&lt;/h3&gt;

&lt;p&gt;上述的这种连接也被称为内连接，连接是建立在两表的相同性上的。内连接还可以用一种&lt;code&gt;ON&lt;/code&gt;分句来替代&lt;code&gt;WHERE&lt;/code&gt;分句，作用是一致的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;SELECT vend_name, prod_name, prod_price
FROM Vendors INNER JOIN Products
	ON Vendors.vend_id=Products.vend_id;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-5&quot;&gt;连接多表&lt;/h3&gt;

&lt;p&gt;连接表的数量是不受限制的，只需要指定关系即可：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;SELECT prod_name, vend_name, prod_price, quantity
FROM OrderItems, Products, Vendors
WHERE Products.vend_id=Vendors.vend_id
	AND OrderItems.prod_id=Products.prod_id
    AND order_num=20007;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;回顾上一讲的子查询，我们可以发现用内连接也可以实现它的功能，下面两个SQL语句的功能就是一致的，具体哪个更高效视情况而定，需要测试。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;SELECT cust_name, cust_contact
FROM Customers
WHERE cust_id IN (SELECT cust_id
				  FROM Orders
                  WHERE order_num IN (SELECT order_num
									  FROM OrderItems
                                      WHERE prod_id=&#39;RGAN01&#39;)); 
                                         
SELECT cust_name, cust_contact
FROM Customers, Orders, OrderItems
WHERE Customers.cust_id=Orders.cust_id
	AND OrderItems.order_num=Orders.order_num
    AND prod_id=&#39;RGAN01&#39;;
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sat, 21 May 2016 00:00:00 +0800</pubDate>
        <link>http://anyinlover.github.io/2016/05/21/joining-tables/</link>
        <guid isPermaLink="true">http://anyinlover.github.io/2016/05/21/joining-tables/</guid>
        
        <category>编程语言</category>
        
        <category>SQL</category>
        
        
      </item>
    
      <item>
        <title>插入数据</title>
        <description>&lt;p&gt;本讲主要学习使用&lt;code&gt;INSERT&lt;/code&gt;语句插入数据。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;理解数据插入&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;SELECT&lt;/code&gt;毫无疑问是最常用的SQL语句，但还有其他三个常用SQL语句，第一个就是&lt;code&gt;INSERT&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;INSERT&lt;/code&gt;用来在数据库表中插入行，有三种用途：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;插入完整单行&lt;/li&gt;
  &lt;li&gt;插入部分单行&lt;/li&gt;
  &lt;li&gt;插入查询结果&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;插入完整单行&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;INSERT INTO Customers
VALUES(&#39;1000000006&#39;,
			&#39;Toy Land&#39;,
            &#39;123 Any Street&#39;,
            &#39;New York&#39;,
            &#39;NY&#39;,
            &#39;11111&#39;,
            &#39;USA&#39;,
            NULL,
            NULL);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这种插入方式严重依赖于列次序，是很不安全的操作，建议用下面的方式插入：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;INSERT INTO Customers(cust_id,
					cust_name,
					cust_address,
					cust_city,
					cust_state,
					cust_zip,
					cust_country,
					cust_contact,
					cust_email)
VALUES(&#39;1000000007&#39;,
			&#39;Toy Land&#39;,
            &#39;123 Any Street&#39;,
            &#39;New York&#39;,
            &#39;NY&#39;,
            &#39;11111&#39;,
            &#39;USA&#39;,
            NULL,
			NULL);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;插入部分单行&lt;/h3&gt;

&lt;p&gt;如果数据库允许某一列的值为空，或有指定的默认值，可以在插入时省略该行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;INSERT INTO Customers(cust_id,
					cust_name,
                    cust_address,
                    cust_city,
                    cust_state,
                    cust_zip,
                    cust_country)
VALUES(&#39;1000000008&#39;,
			&#39;Toy Land&#39;,
            &#39;123 Any Street&#39;,
            &#39;New York&#39;,
            &#39;NY&#39;,
            &#39;11111&#39;,
            &#39;USA&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-3&quot;&gt;插入获取到的数据&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;INSERT&lt;/code&gt;还可以用来插入&lt;code&gt;SELECT&lt;/code&gt;获取到的数据，被称为&lt;code&gt;INSERT SELECT&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;INSERT INTO Customers(cust_id,
					cust_name,
                    cust_address,
                    cust_city,
                    cust_state,
                    cust_zip,
                    cust_country)
			SELECT cust_id,
					cust_name,
                    cust_address,
                    cust_city,
                    cust_state,
                    cust_zip,
                    cust_country
			FROM CustNew;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;INSERT&lt;/code&gt;通常只能插入单行数据，但&lt;code&gt;INSERT SELECT&lt;/code&gt;是个例外，其可以一次性插入多行数据。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;复制表&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;CREATE TABLE CustCopy AS
SELECT * FROM Customers;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;复制表操作在测试新的SQL语句时很有用。	&lt;/p&gt;
</description>
        <pubDate>Sat, 21 May 2016 00:00:00 +0800</pubDate>
        <link>http://anyinlover.github.io/2016/05/21/inserting-data/</link>
        <guid isPermaLink="true">http://anyinlover.github.io/2016/05/21/inserting-data/</guid>
        
        <category>编程语言</category>
        
        <category>SQL</category>
        
        
      </item>
    
  </channel>
</rss>
